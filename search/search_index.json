{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the world of Kubernetes","text":"<p>This guide is designed to help you get started with Kubernetes, the powerful open-source platform for automating microservice deployments, scaling, and management of containerized applications. Whether you're new to Kubernetes or looking to solidify your foundational knowledge, this training will provide you with the basic concepts and hands-on experience needed to start to utilize Kubernetes effectively.</p>"},{"location":"#workshop-structure","title":"Workshop Structure","text":"<p>This training is designed to provide hands-on experience with Kubernetes, covering topics such as:</p> <ul> <li>Kubernetes architecture</li> <li>Deploying and managing applications</li> <li>Networking in Kubernetes</li> <li>Scaling and monitoring</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before starting the training, ensure you have:</p> <ul> <li>Basic knowledge of containers and Docker/ Podman</li> <li>A working installation of Kubernetes (e.g. Minikube or a demo cluster at a cloud provider)</li> <li>Familiarity with the command line</li> </ul>"},{"location":"#references-on-github","title":"References on GitHub","text":"<p>The whole GitHub Repository is linked below:</p> <p>Kubernetes Basic Training - GitHub Repo</p>"},{"location":"#hands-on-labs","title":"Hands-On Labs","text":"<p>For Hands-On-Labs we provide two main usecases. The first use case will lead you to build a container image of a simple web application by yourself. This usecase is divided into two hands-on labs. In the first hands-on lab, Docker or Podman will be used, and in the second hands-on lab, a Kubernetes cluster will be set up with Minikube.  The GitHub repository for the instructions and necessary files is linked below:</p> <p>Webapp-Container-Image</p> <p>The second usecase will show how to deploy an e-commerce application with an underlying microservices architecture. The repository is linked below:</p> <p>E-Commerce</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>These Github pages are based on DevOps principles and are thereby, constantly developed and changed. This means that incomplete information or explanations and exercises that have not yet been fully described cannot be ruled out.</p> <p>Happy learning!</p>"},{"location":"enterprise-solutions/","title":"Enterprise solutions","text":""},{"location":"enterprise-solutions/#enterprise-solutions-like-openshift","title":"Enterprise Solutions like OpenShift","text":"<p>Kubernetes as an open-source solution is great. However, there are a variety of different enterprise solutions on the market that aim to make the life of cluster administrators easier. These enterprise solutions, equipped with a nice UI, customer support, and other pleasant amenities, come at a price. </p> <p>For demo purposes, some providers offer free demo environments for limited periods. In the third hands-on lab, we will deploy an e-commerce microservices application on a demo OpenShift cluster from Red Hat. </p> <p></p> <p>Enjoy the third and for now, the last hands-on lab!</p>"},{"location":"kubernetes-basics/","title":"Kubernetes basics","text":""},{"location":"kubernetes-basics/#lets-start-with-some-basics","title":"Let's start with some Basics","text":"<p>The first part of this workshop will focus on the basic concepts of containerization with Docker or Podman. The theoretical content will be covered in the training itself, while this website will guide the hands-on labs step by step. Specifically, the first hands-on lab will involve building an image from a container file, running it in a container, and finally pushing this image to a repository like Docker Hub.  You can create a Docker Hub account and start pushing images with the link below:</p> <p>Docker Hub</p> <p>Enjoy the first hands-on lab!</p>"},{"location":"orchestration/","title":"Orchestration","text":""},{"location":"orchestration/#orchestration-made-easy-with-minikube","title":"Orchestration made easy with minikube","text":"<p>The larger the sum of microservices that form an application, the more difficult it becomes to manually manage such an application and efficiently deploy resources and time. </p> <p></p> <p>Similar to a large container ship, central management (like a crew and a captain) becomes increasingly relevant with a higher number of containers. </p> <p>One of the most well-known open-source orchestration options is Kubernetes. Kubernetes operates in the form of a cluster, which consists of master or control nodes and worker nodes. </p> <p></p> <p>For practice purposes, it makes sense to map such a cluster in a small scale on a single node to save resources. At this point, the open-source software Minikube comes into play, allowing us to simulate such a Kubernetes cluster and practice with it. </p> <p>Enjoy the second hands-on lab!</p>"},{"location":"kubernetes-core/first-lab/","title":"First Hands-On Lab","text":""},{"location":"kubernetes-core/first-lab/#webapp-in-container","title":"Webapp in Container","text":"<p>This tutorial provides step-by-step instructions for containerizing a web application, building its container image, and deploying it to a local Kubernetes cluster using Minikube. By following this guide, you will learn how to use Podman for container image management and Kubernetes for application deployment.</p>"},{"location":"kubernetes-core/first-lab/#directory-structure","title":"Directory Structure","text":"<p>The <code>webapp_container_image</code> directory contains the following files and subdirectories:</p> <pre><code>webapp_container_image/\n\u251c\u2500\u2500 static_joke_webpage/\n    \u251c\u2500\u2500 Dockerfile          # Defines the container image build instructions.\n    \u251c\u2500\u2500 html/\n        \u251c\u2500\u2500 index.html      # Contains the information and logics of the static webpage.\n\u251c\u2500\u2500 image_accept_webpage/\n    \u251c\u2500\u2500 Dockerfile          # Defines the container image build instructions.\n    \u251c\u2500\u2500 html/\n        \u251c\u2500\u2500 index.html      # Contains the information and logics of the static webpage.\n\u2514\u2500\u2500 README.md               # Documentation with instructions to build, run, push, and deploy the image. \n</code></pre>"},{"location":"kubernetes-core/first-lab/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following tools installed and configured:</p> <ul> <li>Podman or Docker: For building, running, and pushing container images</li> <li>Minikube: As a local light weight kubernetes cluster for deploying the container images (builds up a cluster on a single node)</li> </ul> <p>Instruction to install Podman or Docker and Minikube on different operating systems can be find in their official documentation:</p> <p>Podman Installation Instructions</p> <p>Install Docker Engine</p> <p>minikube start</p> <p>Note</p> <p>Do not forget to set the alias for the minikube kubectl command in the ~/.bashrc as:</p> <pre><code>alias kubectl=\"minikube kubectl --\"\n</code></pre> <p>Otherwise, you always need to type the whole \"minikube kubectl\" command!</p>"},{"location":"kubernetes-core/first-lab/#steps","title":"Steps","text":"<p>Go to the corresponding directory start building and deploying the images with podman or docker.</p> <p>First: \"static_joke_webpage\" </p> <p>Second: \"image_accept_webpage\"</p> <p>For each of the above application, go thorough these steps:</p>"},{"location":"kubernetes-core/first-lab/#1-build-the-image-with-podmandocker","title":"1. Build the Image with Podman/Docker","text":"<p>Run the following command in the directory containing your Containerfile. </p> <p>Thereby you may need to clone the Github Repository with all necessary files prior to the following commands. </p> <pre><code>podman build -t &lt;YOURNAME_image-name&gt;:&lt;YOURNMAE&gt; .\n\n# If you use docker instead: \n\ndocker build -f ./Containerfile -t &lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt; .\n</code></pre> <p>Replace <code>&lt;YOURNAME_image-name&gt;</code> and <code>&lt;tag&gt;</code> with your desired image name and tag. In the case of the Kubernetes Basic Training we would recommend to <code>&lt;tag&gt;</code> your image with your first name to prevent a mess </p> <p>Validate if the image was build up:</p> <pre><code>podman images\n\n# If you use docker instead:\n\ndocker images\n</code></pre>"},{"location":"kubernetes-core/first-lab/#2-run-the-image-with-podmandocker-create-a-container","title":"2. Run the Image with Podman/Docker (Create a Container)","text":"<p>To test the image locally, use:</p> <pre><code>podman run -d -p 8080:8080 &lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt;\n\n# If you use docker instead:\n\ndocker run -d -p 8080:8080 &lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt;\n</code></pre> <p>This maps port 8080 (first port number) on your host to port 8080 (second port number) in the container. You can set an arbitrary port for the host, but container port MUST be 8080.</p> <p>Validate if the container is running:</p> <pre><code>podman ps\n\n# If you use docker instead:\n\ndocker ps\n</code></pre>"},{"location":"kubernetes-core/first-lab/#3-push-the-image-to-a-registry","title":"3. Push the Image to a Registry","text":"<ul> <li>Log in to your container registry (e.g., Docker Hub, Quay.io). It will ask you for your password:</li> </ul> <pre><code>podman login &lt;registry-url&gt; -u &lt;username&gt; \n\n# If you use docker instead: \n\ndocker login &lt;registry-url&gt; -u &lt;username&gt; \n</code></pre> <p>The  is in the case of the Kubernetes Basic Training docker.io registry <ul> <li>Then push the image you just built:</li> </ul> <pre><code># Push image to Docker Hub into an separate repository, just for the newly build image:\n\npodman push &lt;YOURNAME_image-name&gt;:&lt;tag&gt; &lt;registry-url&gt;/&lt;REGISTRY-USERNAME&gt;/&lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt;\n\n# If you use docker instead and want to push image to Docker Hub into an separate repository, just for the newly build image:\n\ndocker push &lt;registry-url&gt;/&lt;REGISTRY-USERNAME&gt;/&lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt;\n\n# If you use docker instead and want to push the image into an existing Repository in your Docker Hub:\n\ndocker tag &lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt; &lt;REGISTRY.USERNAME&gt;/&lt;REPOSITORYNAME&gt;:&lt;YOURNAME&gt;\ndocker push &lt;DOCKERHUB-USERNAME&gt;/&lt;REPOSITORYNAME&gt;:&lt;YOURNAME&gt;\n</code></pre> <p>The repository names:  are the following: <ul> <li>For the \"static_joke_webpage\": static-joke</li> <li>For the \"image_accept_webpage\": image-repository </li> </ul> <p>Replace placeholders with your actual values as needed.</p>"},{"location":"kubernetes-core/second-lab/","title":"Second Hands-On Lab","text":""},{"location":"kubernetes-core/second-lab/#deploy-the-image-locally-using-minikube","title":"Deploy the Image Locally Using Minikube","text":"<ol> <li> <p>Start Minikube:</p> <pre><code>minikube start\n</code></pre> </li> <li> <p>Load the image into Minikube and make sure that is correctly loaded:</p> <pre><code>minikube image load &lt;REGISTRY-USERNAME&gt;/&lt;YOURNAME_image-name&gt;:&lt;YOURNAME&gt;\n\nminikube ssh -- docker images\n</code></pre> </li> <li> <p>Deploy the image as single pod on Minikube:</p> <pre><code>kubectl run &lt;pod-name&gt; --image=&lt;YOURNAME_image-name&gt;:&lt;tag&gt; --port 8080\n</code></pre> </li> <li> <p>At this point, we have two ways to access the webpage (a and b):</p> <ol> <li> <p>We can create a service with type \"ClusterIP\":</p> <pre><code>kubectl expose pod &lt;pod-name&gt; --type=ClusterIP --port=8080 --name &lt;service-name&gt;\n</code></pre> <p>and then use minikube native load balancer to open a tunnel to the service:</p> <pre><code>minikube service &lt;service-name&gt;\n</code></pre> </li> <li> <p>The second method uses the service type \"NodePort\":</p> <pre><code>kubectl expose pod &lt;pod-name&gt; --type=NodePort --port=8080 --name &lt;service-name&gt;\n</code></pre> <p>and the ip address of the minikube's node, which can be obtained from this command:</p> <pre><code>minikube node list\n</code></pre> <p>to access the webpage. For that we need the \"nodePort\" assigned to the service we just created:</p> <pre><code>kubectl get service\n</code></pre> <p>as shown in this image, look for a port number that looks something like this 3XXXX. Kubernetes is assigning NodePorts in range of 30000 and 32767:</p> <p></p> <p>In the browser go the URL that is built from minikube-node-ip and nodeport to see the webpage:</p> <pre><code>URL = http://&lt;minikube-node-ip&gt;:&lt;nodeport&gt;\n</code></pre> </li> </ol> </li> </ol> <p>Replace placeholders with your actual values as needed</p>"},{"location":"kubernetes-core/third-lab/","title":"Third Hands-On Lab","text":""},{"location":"kubernetes-core/third-lab/#hands-on-labs","title":"Hands-On Labs","text":"<p>In this Hands-On-Labs, we deploy an e-commerce application, which is based on the Online Boutique, provided by Google Cloud Platform. </p> <p>The deployment manifests are modified so that they could be deployed on an OpenShift Cluster. The User Interface of \"Online Boutique\" looks like this:</p> <p></p>"},{"location":"kubernetes-core/third-lab/#architecture","title":"Architecture","text":"<p>On the main page of the Online Boutique, a frontend service forwards the requests to the 10 corresponding backend services, as shown in this architectur image: </p> <p></p> <p>All these 11 microservices are communicating over gRPC protocol. </p>"},{"location":"kubernetes-core/third-lab/#microservices","title":"Microservices","text":"<p>These 11 microservices are written in different programming languages and are responsible for a specific task in this e-commerce website:</p> Service Language Description frontend Go Exposes an HTTP server to serve the website. Does not require signup/login and generates session IDs for all users automatically. cartservice C# Stores the items in the user's shopping cart in Redis and retrieves it. productcatalogservice Go Provides the list of products from a JSON file and ability to search products and get individual products. currencyservice Node.js Converts one money amount to another currency. Uses real values fetched from European Central Bank. It's the highest QPS service. paymentservice Node.js Charges the given credit card info (mock) with the given amount and returns a transaction ID. shippingservice Go Gives shipping cost estimates based on the shopping cart. Ships items to the given address (mock) emailservice Python Sends users an order confirmation email (mock). checkoutservice Go Retrieves user cart, prepares order and orchestrates the payment, shipping and the email notification. recommendationservice Python Recommends other products based on what's given in the cart. adservice Java Provides text ads based on given context words. loadgenerator Python/Locust Continuously sends requests imitating realistic user shopping flows to the frontend."},{"location":"kubernetes-core/third-lab/#prerequisites","title":"Prerequisites","text":"<p>Ensure that you have access to a OpenShift Cluster to deploy the manifests for the e-commerce application. </p> <p>Note</p> <p>If you do not already have access to a Demo Cluster, ask your training instructor! Or create a Demo Cluster by yourself via the following link: Red Hat Demo Cluster</p>"},{"location":"kubernetes-core/third-lab/#tutorial-instructions","title":"Tutorial Instructions","text":"<p>We will deploy step by step the manifests in this directory from the OpenShift Console.</p> <p>Login to OpenShift cluster using the provided credentials, create a new project and set the project's name as your provided user (for example \"userX\"): </p> <p></p>"},{"location":"kubernetes-core/third-lab/#frontend-deployment","title":"Frontend Deployment","text":"<p>Now, we will add frontend resources by going to the +Add page:</p> <p></p> <p>and import the corresponding yaml files, that we cloned from the repository earlier, in Import YAML:</p> <p></p> <p>In Import YAML, make sure that you are in the right project (i.e. userx) and then click on Create:</p> <p></p> <p>After some seconds or minutes, it shows that the resources for frontend service are successfully deployed:</p> <p></p> <p>Now, we go to Topology page and click on the arrow at the top right corner to open up the web application in a browser:</p> <p></p> <p>Wait a moment! We did everything correct but still there is an Error and the website is not properly loaded:</p> <p></p> <p>That is because frontend is only the shell of this microservice application and all the backend services are not deployed yet! </p>"},{"location":"kubernetes-core/third-lab/#deploy-backend-services","title":"Deploy Backend Services","text":"<p>At this stage, we will follow the steps described before to add resources for these backend services</p> <ul> <li>adservice.yaml</li> <li>cartservice</li> <li>checkoutservice.yaml</li> <li>currencyservice.yaml</li> <li>loadgenerator.yaml</li> <li>productionservice.yaml</li> <li>recommendationservice.yaml</li> <li>shippingservice.yaml</li> </ul> <p>by importing YAML files from the cloned repo into the same project (i.e. userx) on the cluster and wait some minutes for them to be successfully deployed.</p> <p>YUHU! All part of the puzzle are in running state! But someting is not right! Why are the recommendations and Advertisement not shown!</p> <p>Please compare the website with the link you recieve during the workshop!</p> <p>Tipp: Look into the ports configured in the frontend deployment!</p> <p>After troubleshooting and connecting properly the recommendations and Advertisement services, we go further with add two more services to the application: payment &amp; email</p>"},{"location":"kubernetes-core/third-lab/#deploy-services-payment-and-email-from-terminal","title":"Deploy Services Payment and Email from Terminal","text":"<p>In order to open up a terminal, click on the \"icon\" at top right corner of the console, as shown in the image: </p> <p>Then start a terminal in the window that pops up at the bottom of the page: </p> <p>That should start a workspace pod in your project and provide you with a shell. </p> <p>First, we clone the repositorykubernetes-training:</p> <p></p> <p>Go to the \"kubernetes-training/e-commerce\" directory and run below commands:</p> <ol> <li>deploy email service:</li> </ol> <pre><code>kubectl apply -f emailservice.yaml\n</code></pre> <ol> <li>Deploy payment service: </li> </ol> <pre><code>kubectl apply -f paymentservice.yaml\n</code></pre> <p>Now, it is time to make some money from our website!   </p>"}]}